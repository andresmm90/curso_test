"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var AlwaysData = /** @class */ (function () {
    function AlwaysData() {
        this.type = 'always';
    }
    return AlwaysData;
}());
exports.AlwaysData = AlwaysData;
var OnceData = /** @class */ (function () {
    function OnceData() {
        this.type = 'once';
    }
    return OnceData;
}());
exports.OnceData = OnceData;
var TwiceData = /** @class */ (function () {
    function TwiceData() {
        this.type = 'twice';
    }
    return TwiceData;
}());
exports.TwiceData = TwiceData;
var ThriceData = /** @class */ (function () {
    function ThriceData() {
        this.type = 'thrice';
    }
    return ThriceData;
}());
exports.ThriceData = ThriceData;
var TimesData = /** @class */ (function () {
    function TimesData(count) {
        this.count = count;
        this.type = 'times';
    }
    return TimesData;
}());
exports.TimesData = TimesData;
function buildCompletionChecker(completionCheckerData) {
    if (!completionCheckerData)
        return;
    // Neither of these casts should really be required imo, seem like TS bugs
    var type = completionCheckerData.type;
    var builder = completionCheckerBuilders[type];
    return builder(completionCheckerData);
}
exports.buildCompletionChecker = buildCompletionChecker;
var completionCheckerBuilders = {
    'always': function () { return withExplanation(function () { return false; }, function () {
        return explainUntil(this.requests, Infinity, 'always');
    }); },
    'once': function () { return withExplanation(checkTimes(1), function () {
        return explainUntil(this.requests, 1, 'once');
    }); },
    'twice': function () { return withExplanation(checkTimes(2), function () {
        return explainUntil(this.requests, 2, 'twice');
    }); },
    'thrice': function () { return withExplanation(checkTimes(3), function () {
        return explainUntil(this.requests, 3, 'thrice');
    }); },
    'times': function (_a) {
        var count = _a.count;
        return withExplanation(checkTimes(count), function () {
            return explainUntil(this.requests, count, count + " times");
        });
    }
};
function checkTimes(n) {
    return function () {
        return this.requests.length >= n;
    };
}
function explainUntil(requests, n, name) {
    var seen = requests.length;
    return name + " " + (seen < n ? "(seen " + seen + ")" : "(done)");
}
function withExplanation(functionToExplain, explainer) {
    functionToExplain.explain = explainer;
    return functionToExplain;
}
